\section{Conclusions}

In this paper we have introduced the idea of using a Just In Time compiler for creating simulations of dynamic particle systems. We have then outlined how such a purpose built JIT compiler can take advantage of implicit knowledge and simplified programming requirements. Furthermore we have shown that even a simple implementation can already produce code that is performing at least equivalently or better than conventionally optimized code. Besides direct advantages in performance, having such a JIT compiler also relieves the programmer from having to hand optimize every new simulation rule he might come up with. After the initial effort to create such a JIT compiler its usage provides the best bang for buck for the programmer, he gets the performance of heavily optimized code at the cost of a simple and straight forward implementation. Originally both the conventional code and the JIT compiler were producing SSE code using 128bit wide register with the difference that the JIT compiler only needed little work and changes in the backend to produce new AVX code, while it would be necessary to go over all existing code and redo all the work for the conventional code. This further highlights the advantages of building such an infrastructure, not only to gain immediate performance gains, but also savings for future adjustments when they come along.

Despite the limited scope of this short semester project, we managed to show the value and possible gains of a domain specific JIT compiler, by implementing just a small subset of the tools a conventional compiler uses. In a larger context this also furthers the view that automatic code generation and optimization are worth the effort.

\mypar{Future Work} 
We have already highlighted the possibility of further loop unrolling which allowed the conventional code to partially close the gap to our JIT compiled code. Other possible optimizations not currently implemented include performing algebraic simplifications on the IR and substituting expensive operations such as square roots with fast reverse square root and newton approximations. Another interesting aspect of the online code generation is the possibility to instrument code at runtime and refine heavily used kernels by performing essentially profile guided optimizations for the specific machine the code is currently running on.
